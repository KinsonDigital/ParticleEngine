trigger:
- develop


variables:
  - name: solution
    value: '**/*.sln'
  - name: buildPlatform
    value: 'Any CPU'
  - name: buildConfiguration
    value: 'Debug'
  - name: coverageReportDirName
    value: 'CoverageReport'
  - name: engineLibName
    value: 'ParticleEngine'
  - name: engineTesterAppName
    value: 'ParticleEngineTester'
  - name: pool
    value: 'KinsonDigital'


stages:
- stage: Build_Stage
  displayName: 'Build Stage'
  pool: '$(pool)'
  jobs:
  - job: 'Build_Application_Job'
    displayName: 'Build Application'
    steps:
    - task: NuGetToolInstaller@1
      displayName: 'Set Up Nuget Installer Tool'

    # The MonoGame tool cannot be installed every time due to exit code 1 errors if it is already installed.
    # The workaround is to just update it every time to avoid the error.  Have to ignore failed sources
    # so it can just simply pull the tool down and install it
    - task: CmdLine@2
      displayName: 'Install/Update MonoGame Content Builder Tool'
      inputs:
        script: 'dotnet tool update dotnet-mgcb --tool-path "$(Agent.ToolsDirectory)\MGCB" --ignore-failed-sources'
        workingDirectory: '$(Agent.ToolsDirectory)\'

    - task: CopyFiles@2
      displayName: 'Prepare MGCB Tool For Execution'
      inputs:
        SourceFolder: '$(Agent.ToolsDirectory)\MGCB'
        Contents: '**'
        TargetFolder: '$(System.DefaultWorkingDirectory)\$(engineTesterAppName)\Content'
        OverWrite: true

    - task: CmdLine@2
      displayName: 'Build MonoGame Content With MGCB Tool'
      inputs:
        script: 'mgcb /@:Content.mgcb'
        workingDirectory: '$(System.DefaultWorkingDirectory)\$(engineTesterAppName)\Content'

    - task: NuGetCommand@2
      displayName: 'Restore Nuget Packages'
      inputs:
        command: 'restore'
        restoreSolution: '$(solution)'
        feedsToUse: 'select'
        vstsFeed: '1020f331-f22a-4330-a69a-78abfe6f6372/4c644bf2-f1e8-4f28-a3df-3bc9d3283df9'#KinsonDigitalFeed
        includeNuGetOrg: true

    - task: VSBuild@1
      displayName: 'Build Particle Engine Project'
      inputs:
        solution: '**\$(engineLibName).csproj'
        platform: '$(buildPlatform)'
        configuration: '$(buildConfiguration)'
        clean: true

    - task: VSBuild@1
      displayName: 'Build $(engineTesterAppName) Project'
      inputs:
        solution: '**\$(engineTesterAppName).csproj'
        platform: '$(buildPlatform)'
        configuration: '$(buildConfiguration)'
        clean: true

- stage: Testing_Stage
  displayName: 'Testing Stage'
  pool: '$(pool)'
  dependsOn: 'Build_Stage'
  jobs:
  - job: 'Run_Unit_Tests_Job'
    displayName: 'Run Unit Tests'
    steps:
    - task: DotNetCoreCLI@2
      displayName: "Run ParticleEngine Tests & Collect Code Coverage"
      inputs:
        command: 'test'
        projects: '**\*$(engineLibName)[Tt]ests\*.csproj'
        arguments: '--configuration $(buildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura'
        publishTestResults: true
        testRunTitle: 'Unit Test Results'

    - task: DotNetCoreCLI@2
      displayName: "Run Engine Test App Tests & Collect Code Coverage"
      inputs:
        command: 'test'
        projects: '**\*$(engineTesterAppName)[Tt]ests\*.csproj'
        arguments: '--configuration $(buildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura'
        publishTestResults: true
        testRunTitle: 'Unit Test Results'

    - task: reportgenerator@4
      displayName: 'Generate Code Coverage Reports'
      inputs:
        reports: '**\*.cobertura.xml'
        targetdir: 'CoverageReport'
        sourcedirs: '$(System.DefaultWorkingDirectory)'

    - task: PublishCodeCoverageResults@1
      displayName: "Publish All Code Coverage Results"
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(System.DefaultWorkingDirectory)\$(coverageReportDirName)\Cobertura.xml'
        reportDirectory: '$(System.DefaultWorkingDirectory)\$(coverageReportDirName)'


- stage: Publish_Artifacts_Stage
  displayName: 'Publish Artifacts Stage'
  pool: '$(pool)'
  dependsOn: 'Testing_Stage'
  jobs:
  - job: 'Publish_Artifacts_Job'
    displayName: 'Publish Artifacts'
    steps:

    - task: CmdLine@2
      displayName: 'Display Engine Test App Artifact Path'
      inputs:
        script: 'echo $(System.DefaultWorkingDirectory)\**\$(engineTesterAppName).csproj'
        failOnStderr: true

    - task: DotNetCoreCLI@2
      displayName: 'Publish Engine Test App Artifacts'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: '$(System.DefaultWorkingDirectory)\**\$(engineTesterAppName).csproj'
        arguments: '-o $(System.DefaultWorkingDirectory)\publish -c Release'
        zipAfterPublish: false
        modifyOutputPath: false

    - task: ArchiveFiles@2
      displayName: 'Archive $(engineTesterAppName) Build Results To Staging Directory'
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)\publish'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)\$(engineTesterAppName).zip'
        replaceExistingArchive: true

    - task: CmdLine@2
      displayName: 'Add Version Number To $(engineTesterAppName) Build Artifact'
      inputs:
        script: 'avs --archivepath "$(Build.ArtifactStagingDirectory)\$(engineTesterAppName).zip" --projectfilepath "$(System.DefaultWorkingDirectory)\$(engineTesterAppName)\$(engineTesterAppName).csproj"'
        workingDirectory: 'C:\AVS'
        failOnStderr: true

    - task: PublishBuildArtifacts@1
      displayName: 'Publish $(engineTesterAppName) Build Artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'
        publishLocation: 'Container'
